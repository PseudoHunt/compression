# -*- coding: utf-8 -*-
"""CosineSnappingTest.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XClTQ4BVuCIuVwbTBpAugmzic8s0h1Zm
"""

import torch

@torch.no_grad()
def quantize4_to_int(x, s4, z4):
    """
    Standard 4-bit affine quant: u = x/s4 + z4, then round to [0..15] with clamping.
    Returns integer codes (int32).
    """
    u = x / s4 + z4
    q = torch.round(u)
    q = torch.clamp(q, 0, 15)
    return q.to(torch.int32)

@torch.no_grad()
def dequantize4_from_int(q, s4, z4):
    """Dequantize 4-bit integer codes with scale s4 and zero-point z4."""
    return (q.to(torch.float32) - z4) * s4

@torch.no_grad()
def two_bit_in_four_grid_target_codes(x, s4, z4, b: int = 0):
    """
    Compute the 4-bit integer codes that correspond to 2-bit quantization
    embedded in a 4-bit grid with offset b in {0,2}.
      - b = 0 -> {0,4,8,12}
      - b = 2 -> {2,6,10,14}
    """
    u = x / s4 + z4                     # real-valued code space
    # Project onto sub-grid by rounding every 4 steps from offset b
    k = torch.round((u - b) / 4.0)
    q2 = b + 4.0 * k
    # Clamp to valid 4-bit range
    q2 = torch.clamp(q2, 0.0, 15.0)
    return q2.to(torch.int32)

@torch.no_grad()
def cosine_snap_alpha(
    x: torch.Tensor,
    s4: torch.Tensor,
    z4: torch.Tensor,
    b: int = 0,
    snap_strength: float = 1.0,
    eps: float = 1e-6,
):
    """
    Compute alpha (same units as x) so that 4-bit quantize(x + alpha) == 2-bit-in-4-bit codes.

    Mechanism:
    1) Cosine snapping: a smooth, periodic bias nudging (x/s4+z4) toward the chosen sub-grid.
       This is controlled by `snap_strength` in [0, 1]. 0 = no nudge, 1 = full nudge amplitude.
    2) Minimal correction: the smallest extra shift in code space that GUARANTEES the final
       4-bit rounding lands on the exact target sub-grid code. This gives exact equality.

    Arguments
    ---------
    x : tensor of weights/activations
    s4, z4 : broadcastable scale and zero-point for 4-bit affine quantization
    b : int in {0, 2}, sub-grid offset: {0,4,8,12} or {2,6,10,14}
    snap_strength : float in [0,1], how strongly the cosine term nudges toward sub-grid
    eps : small number to avoid tie-on-boundary cases

    Returns
    -------
    alpha : tensor, same shape as x
    """
    # ---- Target integer codes on the 2-bit-in-4-bit grid
    q2 = two_bit_in_four_grid_target_codes(x, s4, z4, b=b).to(torch.float32)

    # ---- Current real-valued codes
    u = x / s4 + z4  # real code space

    # ---- Cosine snapping in code space (period = 4)
    # Phase in [0,4): position inside the 4-step block aligned to b
    phase = (u - b) - 4.0 * torch.floor((u - b) / 4.0)
    # Cosine window centered on the sub-grid codes; zero at midpoints between them.
    # Range of cos term: [-1, 1]. We want zero push at the target codes and max push near midpoints.
    cos_term = torch.cos(2.0 * torch.pi * phase / 4.0)  # cos(Ï€/2 * phase)

    # Amplitude: up to 0.5 code-step so it cannot on its own flip to a wrong integer,
    # scaled by snap_strength in [0,1].
    # Positive sign pushes toward the nearest sub-grid point.
    alpha_code_cos = 0.5 * snap_strength * cos_term

    # Apply the cosine nudge (in code space), then figure out the integer we'd get
    u_snapped = u + alpha_code_cos
    q_after_snap = torch.round(u_snapped)

    # ---- Minimal corrective shift to GUARANTEE we hit q2
    # If we already landed on q2, no extra shift needed.
    need_fix = (q_after_snap != q2)

    # To force round(u + alpha_total) == q2, we must land inside [q2-0.5, q2+0.5).
    # Minimal shift magnitude needed from u_snapped to enter that interval:
    delta = q2 - u_snapped  # how far to the center
    # distance outside the rounding cell:
    outside = torch.clamp(torch.abs(delta) - 0.5, min=0.0)
    # move in the right direction by exactly that amount (+ a tiny eps) to be strictly inside
    alpha_code_fix = torch.sign(delta) * (outside + eps)

    # Only apply the fix where needed
    alpha_code = torch.where(need_fix, alpha_code_cos + alpha_code_fix, alpha_code_cos)

    # Convert code-space alpha to value-space alpha
    alpha_value = alpha_code * s4
    return alpha_value

# -----------------------
# Example usage
# -----------------------
if __name__ == "__main__":
    torch.manual_seed(0)
    x = torch.randn(8) * 0.02  # toy weights
    s4 = torch.tensor(0.005)   # example 4-bit scale
    z4 = torch.tensor(8.0)     # example 4-bit zero-point (asymmetric)

    # Choose 2-bit grid offset: b=0 -> {0,4,8,12}; b=2 -> {2,6,10,14}
    b = 2

    # Compute alpha
    alpha = cosine_snap_alpha(x, s4, z4, b=b, snap_strength=1.0)

    # Verify exact equality:
    q_4_direct = quantize4_to_int(x + alpha, s4, z4)
    q_2in4     = two_bit_in_four_grid_target_codes(x, s4, z4, b=b)
    assert torch.all(q_4_direct == q_2in4), "Verification failed: codes mismatch."

    # (Optional) dequantize to see final values
    xq = dequantize4_from_int(q_4_direct, s4, z4)
    print("x:", x)
    print("alpha:", alpha)
    print("4-bit codes after (x+alpha):", q_4_direct)
    print("2-bit-in-4-bit target codes:", q_2in4)
    print("dequantized:", xq)